Summary:
Filters are not properly applied in certain cases
Description:
Steps to reproduce:
Create a table, load data into it. Flush the table.
Do a scan with
1. Some filter which should not match the first entry in the scan
2. Where one specifies a family and column.
You will notice that the first entry is returned even though it doesn't match the filter.
It looks like the when the first KeyValue of a scan in the column from the point of view of the code
HRegion.java
} else if (kv != null && !kv.isInternal() && filterRowKey(currentRow)) {
Is generated by
public static KeyValue createLastOnRow(final byte [] row,
final int roffset, final int rlength, final byte [] family,
final int foffset, final int flength, final byte [] qualifier,
final int qoffset, final int qlength) { return new KeyValue(row, roffset, rlength, family, foffset, flength, qualifier, qoffset, qlength, HConstants.OLDEST_TIMESTAMP, Type.Minimum, null, 0, 0); }
So it is always internal from that point of the code.
Only later from within
StoreScanner.java
public synchronized boolean next(List<KeyValue> outResult, int limit, String metric) throws IOException {
....
LOOP: while((kv = this.heap.peek()) != null) {
( The second time through)
Do we get the actual kv, with a proper type and timestamp. This seems to mess with filtering.
Status:
CLOSED
Priority:
Major
Resolution:
Fixed
Affects_version:
0.94.1
Fix_version:
0.94.2
Component:
None
Label:
None
Environment:

Attachment number:
0
Assignee:
Lars Hofhansl
Reporter:
Alex Newman
Create date:
01/Oct/12 23:40
Update date:
07/Apr/13 05:07
Resolved date:
04/Oct/12 00:41
